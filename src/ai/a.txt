generateRandomMove(self, state: State, n_player: int) -> Tuple[str, str]:
    Generates a random move based on the current state of the game.

generatingPossibleMoves(self, state: State, n_player: int) -> Tuple[int, str]:
	Function to generate possible move that current player can do. The order of the move are optimized 
    with static heuristic.

is_placeable(self, board:Board, row:int, col:int ) -> bool:
	Function to check can we place piece at column "col" and row "row".

check_placeable_tiles_at_direction(self, board:Board, start:Tuple[int, int], end:Tuple[int, int], dir:Tuple[int, int]) -> int:
	Function to check number of free placeable tile on direction.

check_3_streak_split(self, board: Board, location:Tuple[int, int],  dir:Tuple[int, int]) -> Tuple[str, str]:
	Function to check 2 streak followed by blank then the same piece from row, col in current board 
    with specific direction.

check_n_streak_at_direction(self, n_streak:int, board: Board, location:Tuple[int, int],  dir:Tuple[int, int]) -> Tuple[str, str]:
	Function to check n streak from row, col in current board with specific direction.

countObjectiveIsWin(self, state: State) -> int
	Function to count heuristic function if a winner is found.

countObjectiveType3(self, col:int) -> float:
	Function to count heuristic state value if current piece is single horsemen. 
	The heuristic value depend on how many streak is possible.

countObjectiveType2(self, board:Board, location:Tuple[int, int],  dir:Tuple[int, int]) -> float:
	Function to count heuristic state value if Type2 exist. Type2 happen where there are 
	two connected piece in some way. The heuristic value depend on free tile on direction.

countObjectiveType1(self, state:State, location:Tuple[int, int],  dir:Tuple[int, int]) -> float:
	Function to count heuristic state value if Type1 exist. Type1 happen where there are 
	three connected piece in some way.

calculateValue(self, state: State, n_player:int) -> float:
	Function that is used to calculate the value of a state.